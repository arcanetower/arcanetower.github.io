(function(){
  if (typeof window === 'undefined' || typeof window.L === 'undefined') return;
  // Minimal lightweight implementation of L.timeline to support this project.
  // It wraps each GeoJSON feature with L.geoJSON and toggles feature layers based on interval returned by options.getInterval(feature)
  L.timeline = function(geojson, options) {
    options = options || {};
    var features = (geojson && geojson.features) ? geojson.features.slice() : [];
    var featureLayers = []; // {feature, layer, interval}
    var _map = null;
    var _group = null;
    var _currentTime = null;

    function makeLayerForFeature(feature) {
      // Use L.geoJSON for full feature rendering so pointToLayer/style/onEachFeature work
      var geoOpts = {};
      if (options.pointToLayer) geoOpts.pointToLayer = options.pointToLayer;
      if (options.style) geoOpts.style = options.style;
      if (options.onEachFeature) geoOpts.onEachFeature = options.onEachFeature;
      var layer = L.geoJSON(feature, geoOpts);
      return layer;
    }

    features.forEach(function(f){
      var interval = null;
      try { interval = options.getInterval ? options.getInterval(f) : null; } catch(e) { interval = null; }
      var layer = makeLayerForFeature(f);
      featureLayers.push({feature: f, layer: layer, interval: interval});
    });

    function addLayerToMap(layer) {
      if (!_group) {
        _group = L.layerGroup();
        if (_map) _group.addTo(_map);
      }
      // If the provided layer is a group (e.g. L.geoJSON created multiple child layers)
      // add its inner layers to the internal _group so they are visible on the map.
      try {
        if (layer && typeof layer.getLayers === 'function') {
          var children = layer.getLayers();
          for (var i = 0; i < children.length; i++) {
            var child = children[i];
            if (!_group.hasLayer(child)) _group.addLayer(child);
          }
          // keep a reference on the wrapper so it can be removed later
          layer._tl_childLayers = children.slice();
        } else {
          if (!_group.hasLayer(layer)) _group.addLayer(layer);
        }
      } catch (e) {
        // fallback: try to add whole layer
        if (!_group.hasLayer(layer)) _group.addLayer(layer);
      }
    }
    function removeLayerFromMap(layer) {
      if (!_group) return;
      try {
        if (layer && Array.isArray(layer._tl_childLayers)) {
          layer._tl_childLayers.forEach(function(child){ if (_group.hasLayer(child)) _group.removeLayer(child); });
          layer._tl_childLayers = null;
        } else if (_group.hasLayer(layer)) {
          _group.removeLayer(layer);
        }
      } catch (e) {
        try { if (_group.hasLayer(layer)) _group.removeLayer(layer); } catch(e){}
      }
    }

    function setTime(ms) {
      _currentTime = ms;
      featureLayers.forEach(function(fl){
        var iv = fl.interval;
        if (Array.isArray(iv) && iv.length === 2 && typeof ms === 'number') {
          if (ms >= iv[0] && ms <= iv[1]) {
            // show
            if (!fl._visible) {
              addLayerToMap(fl.layer);
              fl._visible = true;
              try { if (options && typeof options.onFeatureShow === 'function') options.onFeatureShow(fl.feature, fl.layer); } catch(e){}
            }
          } else {
            // hide
            if (fl._visible) {
              removeLayerFromMap(fl.layer);
              fl._visible = false;
              try { if (options && typeof options.onFeatureHide === 'function') options.onFeatureHide(fl.feature, fl.layer); } catch(e){}
            }
          }
        } else {
          // no interval -> ensure hidden
          if (fl._visible) {
            removeLayerFromMap(fl.layer);
            fl._visible = false;
            try { if (options && typeof options.onFeatureHide === 'function') options.onFeatureHide(fl.feature, fl.layer); } catch(e){}
          }
        }
      });
    }

    function addTo(map) {
      _map = map;
      if (!_group) _group = L.layerGroup().addTo(_map);
      // if a time is already set, apply it
      if (_currentTime !== null) setTime(_currentTime);
      return this;
    }

    function addLayer(layer) { if (_group) _group.addLayer(layer); }
    function remove() {
      // call onFeatureHide for any visible features so consumers can cleanup (image overlays etc)
      try {
        if (Array.isArray(featureLayers)) {
          featureLayers.forEach(function(fl){
            if (fl._visible) {
              try { if (options && typeof options.onFeatureHide === 'function') options.onFeatureHide(fl.feature, fl.layer); } catch(e){}
              fl._visible = false;
            }
          });
        }
      } catch(e){}
      if (_group && _map) _map.removeLayer(_group);
      _group = null;
    }

    // minimal API expected by the page
    return {
      addTo: addTo,
      setTime: setTime,
      // expose underlying for compatibility
      _featureLayers: featureLayers,
      _geojson: geojson,
      // convenience
      addLayer: addLayer,
      remove: remove
    };
  };
})();
